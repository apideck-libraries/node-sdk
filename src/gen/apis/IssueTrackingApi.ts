/* tslint:disable */
/* eslint-disable */
/**
 * Apideck
 * The Apideck OpenAPI Spec: SDK Optimized
 *
 * The version of the OpenAPI document: 9.9.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
  CollectionsSort,
  CollectionTicketComment,
  CollectionTicketCommentToJSON,
  CommentsSort,
  CreateCommentResponse,
  CreateCommentResponseFromJSON,
  CreateTicketResponse,
  CreateTicketResponseFromJSON,
  DeleteCommentResponse,
  DeleteCommentResponseFromJSON,
  DeleteTicketResponse,
  DeleteTicketResponseFromJSON,
  GetCollectionResponse,
  GetCollectionResponseFromJSON,
  GetCollectionsResponse,
  GetCollectionsResponseFromJSON,
  GetCollectionTagsResponse,
  GetCollectionTagsResponseFromJSON,
  GetCollectionUserResponse,
  GetCollectionUserResponseFromJSON,
  GetCollectionUsersResponse,
  GetCollectionUsersResponseFromJSON,
  GetCommentResponse,
  GetCommentResponseFromJSON,
  GetCommentsResponse,
  GetCommentsResponseFromJSON,
  GetTicketResponse,
  GetTicketResponseFromJSON,
  GetTicketsResponse,
  GetTicketsResponseFromJSON,
  IssuesFilter,
  PassThroughQuery,
  Ticket,
  TicketsSort,
  TicketToJSON,
  UpdateCommentResponse,
  UpdateCommentResponseFromJSON,
  UpdateTicketResponse,
  UpdateTicketResponseFromJSON
} from '../models'
import * as runtime from '../runtime'

export interface IssueTrackingApiCollectionTagsAllRequest {
  collectionId: string
  raw?: boolean
  consumerId?: string
  appId?: string
  serviceId?: string
  cursor?: string | null
  limit?: number
  passThrough?: PassThroughQuery
  fields?: string | null
}

export interface IssueTrackingApiCollectionTicketCommentsAddRequest {
  collectionId: string
  ticketId: string
  ticketComment: CollectionTicketComment
  raw?: boolean
  consumerId?: string
  appId?: string
  serviceId?: string
}

export interface IssueTrackingApiCollectionTicketCommentsAllRequest {
  collectionId: string
  ticketId: string
  raw?: boolean
  consumerId?: string
  appId?: string
  serviceId?: string
  cursor?: string | null
  limit?: number
  sort?: CommentsSort
  passThrough?: PassThroughQuery
  fields?: string | null
}

export interface IssueTrackingApiCollectionTicketCommentsDeleteRequest {
  id: string
  collectionId: string
  ticketId: string
  consumerId?: string
  appId?: string
  serviceId?: string
  raw?: boolean
}

export interface IssueTrackingApiCollectionTicketCommentsOneRequest {
  id: string
  collectionId: string
  ticketId: string
  raw?: boolean
  consumerId?: string
  appId?: string
  serviceId?: string
  cursor?: string | null
  limit?: number
  fields?: string | null
}

export interface IssueTrackingApiCollectionTicketCommentsUpdateRequest {
  id: string
  collectionId: string
  ticketId: string
  ticketComment: CollectionTicketComment
  consumerId?: string
  appId?: string
  serviceId?: string
  raw?: boolean
}

export interface IssueTrackingApiCollectionTicketsAddRequest {
  collectionId: string
  ticket: Ticket
  raw?: boolean
  consumerId?: string
  appId?: string
  serviceId?: string
}

export interface IssueTrackingApiCollectionTicketsAllRequest {
  collectionId: string
  raw?: boolean
  consumerId?: string
  appId?: string
  serviceId?: string
  cursor?: string | null
  limit?: number
  sort?: TicketsSort
  filter?: IssuesFilter
  passThrough?: PassThroughQuery
  fields?: string | null
}

export interface IssueTrackingApiCollectionTicketsDeleteRequest {
  ticketId: string
  collectionId: string
  consumerId?: string
  appId?: string
  serviceId?: string
  raw?: boolean
}

export interface IssueTrackingApiCollectionTicketsOneRequest {
  ticketId: string
  collectionId: string
  consumerId?: string
  appId?: string
  serviceId?: string
  raw?: boolean
  fields?: string | null
}

export interface IssueTrackingApiCollectionTicketsUpdateRequest {
  ticketId: string
  collectionId: string
  ticket: Ticket
  consumerId?: string
  appId?: string
  serviceId?: string
  raw?: boolean
}

export interface IssueTrackingApiCollectionUsersAllRequest {
  collectionId: string
  raw?: boolean
  consumerId?: string
  appId?: string
  serviceId?: string
  cursor?: string | null
  limit?: number
  passThrough?: PassThroughQuery
  fields?: string | null
}

export interface IssueTrackingApiCollectionUsersOneRequest {
  collectionId: string
  id: string
  consumerId?: string
  appId?: string
  serviceId?: string
  raw?: boolean
  fields?: string | null
}

export interface IssueTrackingApiCollectionsAllRequest {
  raw?: boolean
  consumerId?: string
  appId?: string
  serviceId?: string
  cursor?: string | null
  limit?: number
  sort?: CollectionsSort
  passThrough?: PassThroughQuery
  fields?: string | null
}

export interface IssueTrackingApiCollectionsOneRequest {
  collectionId: string
  consumerId?: string
  appId?: string
  serviceId?: string
  raw?: boolean
  fields?: string | null
}

/**
 *
 */
export class IssueTrackingApi extends runtime.BaseAPI {
  /**
   * List Tags
   * List Tags
   */
  async collectionTagsAllRaw(
    requestParameters: IssueTrackingApiCollectionTagsAllRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<GetCollectionTagsResponse>> {
    if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
      throw new runtime.RequiredError(
        'collectionId',
        'Required parameter requestParameters.collectionId was null or undefined when calling collectionTagsAll.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.raw !== undefined) {
      queryParameters['raw'] = requestParameters.raw
    }

    if (requestParameters.cursor !== undefined) {
      queryParameters['cursor'] = requestParameters.cursor
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.passThrough !== undefined) {
      queryParameters['pass_through'] = requestParameters.passThrough
    }

    if (requestParameters.fields !== undefined) {
      queryParameters['fields'] = requestParameters.fields
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (requestParameters.consumerId !== undefined && requestParameters.consumerId !== null) {
      headerParameters['x-apideck-consumer-id'] = String(requestParameters.consumerId)
    }

    if (requestParameters.appId !== undefined && requestParameters.appId !== null) {
      headerParameters['x-apideck-app-id'] = String(requestParameters.appId)
    }

    if (requestParameters.serviceId !== undefined && requestParameters.serviceId !== null) {
      headerParameters['x-apideck-service-id'] = String(requestParameters.serviceId)
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = this.configuration.apiKey('Authorization') // apiKey authentication
    }

    const response = await this.request(
      {
        path: `/issue-tracking/collections/{collection_id}/tags`.replace(
          `{${'collection_id'}}`,
          encodeURIComponent(String(requestParameters.collectionId))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue =>
      GetCollectionTagsResponseFromJSON(jsonValue)
    )
  }

  /**
   * List Tags
   * List Tags
   */
  async collectionTagsAll(
    requestParameters: IssueTrackingApiCollectionTagsAllRequest,
    initOverrides?: RequestInit
  ): Promise<GetCollectionTagsResponse> {
    const response = await this.collectionTagsAllRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Create Comment
   * Create Comment
   */
  async ticketCommentsAddRaw(
    requestParameters: IssueTrackingApiCollectionTicketCommentsAddRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<CreateCommentResponse>> {
    if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
      throw new runtime.RequiredError(
        'collectionId',
        'Required parameter requestParameters.collectionId was null or undefined when calling ticketCommentsAdd.'
      )
    }

    if (requestParameters.ticketId === null || requestParameters.ticketId === undefined) {
      throw new runtime.RequiredError(
        'ticketId',
        'Required parameter requestParameters.ticketId was null or undefined when calling ticketCommentsAdd.'
      )
    }

    if (requestParameters.ticketComment === null || requestParameters.ticketComment === undefined) {
      throw new runtime.RequiredError(
        'ticketComment',
        'Required parameter requestParameters.ticketComment was null or undefined when calling ticketCommentsAdd.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.raw !== undefined) {
      queryParameters['raw'] = requestParameters.raw
    }

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (requestParameters.consumerId !== undefined && requestParameters.consumerId !== null) {
      headerParameters['x-apideck-consumer-id'] = String(requestParameters.consumerId)
    }

    if (requestParameters.appId !== undefined && requestParameters.appId !== null) {
      headerParameters['x-apideck-app-id'] = String(requestParameters.appId)
    }

    if (requestParameters.serviceId !== undefined && requestParameters.serviceId !== null) {
      headerParameters['x-apideck-service-id'] = String(requestParameters.serviceId)
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = this.configuration.apiKey('Authorization') // apiKey authentication
    }

    const response = await this.request(
      {
        path: `/issue-tracking/collections/{collection_id}/tickets/{ticket_id}/comments`
          .replace(
            `{${'collection_id'}}`,
            encodeURIComponent(String(requestParameters.collectionId))
          )
          .replace(`{${'ticket_id'}}`, encodeURIComponent(String(requestParameters.ticketId))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: CollectionTicketCommentToJSON(requestParameters.ticketComment)
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue =>
      CreateCommentResponseFromJSON(jsonValue)
    )
  }

  /**
   * Create Comment
   * Create Comment
   */
  async ticketCommentsAdd(
    requestParameters: IssueTrackingApiCollectionTicketCommentsAddRequest,
    initOverrides?: RequestInit
  ): Promise<CreateCommentResponse> {
    const response = await this.ticketCommentsAddRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * List Comments
   * List Comments
   */
  async ticketCommentsAllRaw(
    requestParameters: IssueTrackingApiCollectionTicketCommentsAllRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<GetCommentsResponse>> {
    if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
      throw new runtime.RequiredError(
        'collectionId',
        'Required parameter requestParameters.collectionId was null or undefined when calling ticketCommentsAll.'
      )
    }

    if (requestParameters.ticketId === null || requestParameters.ticketId === undefined) {
      throw new runtime.RequiredError(
        'ticketId',
        'Required parameter requestParameters.ticketId was null or undefined when calling ticketCommentsAll.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.raw !== undefined) {
      queryParameters['raw'] = requestParameters.raw
    }

    if (requestParameters.cursor !== undefined) {
      queryParameters['cursor'] = requestParameters.cursor
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort
    }

    if (requestParameters.passThrough !== undefined) {
      queryParameters['pass_through'] = requestParameters.passThrough
    }

    if (requestParameters.fields !== undefined) {
      queryParameters['fields'] = requestParameters.fields
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (requestParameters.consumerId !== undefined && requestParameters.consumerId !== null) {
      headerParameters['x-apideck-consumer-id'] = String(requestParameters.consumerId)
    }

    if (requestParameters.appId !== undefined && requestParameters.appId !== null) {
      headerParameters['x-apideck-app-id'] = String(requestParameters.appId)
    }

    if (requestParameters.serviceId !== undefined && requestParameters.serviceId !== null) {
      headerParameters['x-apideck-service-id'] = String(requestParameters.serviceId)
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = this.configuration.apiKey('Authorization') // apiKey authentication
    }

    const response = await this.request(
      {
        path: `/issue-tracking/collections/{collection_id}/tickets/{ticket_id}/comments`
          .replace(
            `{${'collection_id'}}`,
            encodeURIComponent(String(requestParameters.collectionId))
          )
          .replace(`{${'ticket_id'}}`, encodeURIComponent(String(requestParameters.ticketId))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue =>
      GetCommentsResponseFromJSON(jsonValue)
    )
  }

  /**
   * List Comments
   * List Comments
   */
  async ticketCommentsAll(
    requestParameters: IssueTrackingApiCollectionTicketCommentsAllRequest,
    initOverrides?: RequestInit
  ): Promise<GetCommentsResponse> {
    const response = await this.ticketCommentsAllRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Delete Comment
   * Delete Comment
   */
  async ticketCommentsDeleteRaw(
    requestParameters: IssueTrackingApiCollectionTicketCommentsDeleteRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<DeleteCommentResponse>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling ticketCommentsDelete.'
      )
    }

    if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
      throw new runtime.RequiredError(
        'collectionId',
        'Required parameter requestParameters.collectionId was null or undefined when calling ticketCommentsDelete.'
      )
    }

    if (requestParameters.ticketId === null || requestParameters.ticketId === undefined) {
      throw new runtime.RequiredError(
        'ticketId',
        'Required parameter requestParameters.ticketId was null or undefined when calling ticketCommentsDelete.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.raw !== undefined) {
      queryParameters['raw'] = requestParameters.raw
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (requestParameters.consumerId !== undefined && requestParameters.consumerId !== null) {
      headerParameters['x-apideck-consumer-id'] = String(requestParameters.consumerId)
    }

    if (requestParameters.appId !== undefined && requestParameters.appId !== null) {
      headerParameters['x-apideck-app-id'] = String(requestParameters.appId)
    }

    if (requestParameters.serviceId !== undefined && requestParameters.serviceId !== null) {
      headerParameters['x-apideck-service-id'] = String(requestParameters.serviceId)
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = this.configuration.apiKey('Authorization') // apiKey authentication
    }

    const response = await this.request(
      {
        path: `/issue-tracking/collections/{collection_id}/tickets/{ticket_id}/comments/{id}`
          .replace(`{${'id'}}`, encodeURIComponent(String(requestParameters.id)))
          .replace(
            `{${'collection_id'}}`,
            encodeURIComponent(String(requestParameters.collectionId))
          )
          .replace(`{${'ticket_id'}}`, encodeURIComponent(String(requestParameters.ticketId))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue =>
      DeleteCommentResponseFromJSON(jsonValue)
    )
  }

  /**
   * Delete Comment
   * Delete Comment
   */
  async ticketCommentsDelete(
    requestParameters: IssueTrackingApiCollectionTicketCommentsDeleteRequest,
    initOverrides?: RequestInit
  ): Promise<DeleteCommentResponse> {
    const response = await this.ticketCommentsDeleteRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Get Comment
   * Get Comment
   */
  async ticketCommentsOneRaw(
    requestParameters: IssueTrackingApiCollectionTicketCommentsOneRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<GetCommentResponse>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling ticketCommentsOne.'
      )
    }

    if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
      throw new runtime.RequiredError(
        'collectionId',
        'Required parameter requestParameters.collectionId was null or undefined when calling ticketCommentsOne.'
      )
    }

    if (requestParameters.ticketId === null || requestParameters.ticketId === undefined) {
      throw new runtime.RequiredError(
        'ticketId',
        'Required parameter requestParameters.ticketId was null or undefined when calling ticketCommentsOne.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.raw !== undefined) {
      queryParameters['raw'] = requestParameters.raw
    }

    if (requestParameters.cursor !== undefined) {
      queryParameters['cursor'] = requestParameters.cursor
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.fields !== undefined) {
      queryParameters['fields'] = requestParameters.fields
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (requestParameters.consumerId !== undefined && requestParameters.consumerId !== null) {
      headerParameters['x-apideck-consumer-id'] = String(requestParameters.consumerId)
    }

    if (requestParameters.appId !== undefined && requestParameters.appId !== null) {
      headerParameters['x-apideck-app-id'] = String(requestParameters.appId)
    }

    if (requestParameters.serviceId !== undefined && requestParameters.serviceId !== null) {
      headerParameters['x-apideck-service-id'] = String(requestParameters.serviceId)
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = this.configuration.apiKey('Authorization') // apiKey authentication
    }

    const response = await this.request(
      {
        path: `/issue-tracking/collections/{collection_id}/tickets/{ticket_id}/comments/{id}`
          .replace(`{${'id'}}`, encodeURIComponent(String(requestParameters.id)))
          .replace(
            `{${'collection_id'}}`,
            encodeURIComponent(String(requestParameters.collectionId))
          )
          .replace(`{${'ticket_id'}}`, encodeURIComponent(String(requestParameters.ticketId))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue => GetCommentResponseFromJSON(jsonValue))
  }

  /**
   * Get Comment
   * Get Comment
   */
  async ticketCommentsOne(
    requestParameters: IssueTrackingApiCollectionTicketCommentsOneRequest,
    initOverrides?: RequestInit
  ): Promise<GetCommentResponse> {
    const response = await this.ticketCommentsOneRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Update Comment
   * Update Comment
   */
  async ticketCommentsUpdateRaw(
    requestParameters: IssueTrackingApiCollectionTicketCommentsUpdateRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<UpdateCommentResponse>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling ticketCommentsUpdate.'
      )
    }

    if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
      throw new runtime.RequiredError(
        'collectionId',
        'Required parameter requestParameters.collectionId was null or undefined when calling ticketCommentsUpdate.'
      )
    }

    if (requestParameters.ticketId === null || requestParameters.ticketId === undefined) {
      throw new runtime.RequiredError(
        'ticketId',
        'Required parameter requestParameters.ticketId was null or undefined when calling ticketCommentsUpdate.'
      )
    }

    if (requestParameters.ticketComment === null || requestParameters.ticketComment === undefined) {
      throw new runtime.RequiredError(
        'ticketComment',
        'Required parameter requestParameters.ticketComment was null or undefined when calling ticketCommentsUpdate.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.raw !== undefined) {
      queryParameters['raw'] = requestParameters.raw
    }

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (requestParameters.consumerId !== undefined && requestParameters.consumerId !== null) {
      headerParameters['x-apideck-consumer-id'] = String(requestParameters.consumerId)
    }

    if (requestParameters.appId !== undefined && requestParameters.appId !== null) {
      headerParameters['x-apideck-app-id'] = String(requestParameters.appId)
    }

    if (requestParameters.serviceId !== undefined && requestParameters.serviceId !== null) {
      headerParameters['x-apideck-service-id'] = String(requestParameters.serviceId)
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = this.configuration.apiKey('Authorization') // apiKey authentication
    }

    const response = await this.request(
      {
        path: `/issue-tracking/collections/{collection_id}/tickets/{ticket_id}/comments/{id}`
          .replace(`{${'id'}}`, encodeURIComponent(String(requestParameters.id)))
          .replace(
            `{${'collection_id'}}`,
            encodeURIComponent(String(requestParameters.collectionId))
          )
          .replace(`{${'ticket_id'}}`, encodeURIComponent(String(requestParameters.ticketId))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: CollectionTicketCommentToJSON(requestParameters.ticketComment)
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue =>
      UpdateCommentResponseFromJSON(jsonValue)
    )
  }

  /**
   * Update Comment
   * Update Comment
   */
  async ticketCommentsUpdate(
    requestParameters: IssueTrackingApiCollectionTicketCommentsUpdateRequest,
    initOverrides?: RequestInit
  ): Promise<UpdateCommentResponse> {
    const response = await this.ticketCommentsUpdateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Create Ticket
   * Create Ticket
   */
  async ticketsAddRaw(
    requestParameters: IssueTrackingApiCollectionTicketsAddRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<CreateTicketResponse>> {
    if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
      throw new runtime.RequiredError(
        'collectionId',
        'Required parameter requestParameters.collectionId was null or undefined when calling ticketsAdd.'
      )
    }

    if (requestParameters.ticket === null || requestParameters.ticket === undefined) {
      throw new runtime.RequiredError(
        'ticket',
        'Required parameter requestParameters.ticket was null or undefined when calling ticketsAdd.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.raw !== undefined) {
      queryParameters['raw'] = requestParameters.raw
    }

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (requestParameters.consumerId !== undefined && requestParameters.consumerId !== null) {
      headerParameters['x-apideck-consumer-id'] = String(requestParameters.consumerId)
    }

    if (requestParameters.appId !== undefined && requestParameters.appId !== null) {
      headerParameters['x-apideck-app-id'] = String(requestParameters.appId)
    }

    if (requestParameters.serviceId !== undefined && requestParameters.serviceId !== null) {
      headerParameters['x-apideck-service-id'] = String(requestParameters.serviceId)
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = this.configuration.apiKey('Authorization') // apiKey authentication
    }

    const response = await this.request(
      {
        path: `/issue-tracking/collections/{collection_id}/tickets`.replace(
          `{${'collection_id'}}`,
          encodeURIComponent(String(requestParameters.collectionId))
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: TicketToJSON(requestParameters.ticket)
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue =>
      CreateTicketResponseFromJSON(jsonValue)
    )
  }

  /**
   * Create Ticket
   * Create Ticket
   */
  async ticketsAdd(
    requestParameters: IssueTrackingApiCollectionTicketsAddRequest,
    initOverrides?: RequestInit
  ): Promise<CreateTicketResponse> {
    const response = await this.ticketsAddRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * List Tickets
   * List Tickets
   */
  async ticketsAllRaw(
    requestParameters: IssueTrackingApiCollectionTicketsAllRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<GetTicketsResponse>> {
    if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
      throw new runtime.RequiredError(
        'collectionId',
        'Required parameter requestParameters.collectionId was null or undefined when calling ticketsAll.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.raw !== undefined) {
      queryParameters['raw'] = requestParameters.raw
    }

    if (requestParameters.cursor !== undefined) {
      queryParameters['cursor'] = requestParameters.cursor
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort
    }

    if (requestParameters.filter !== undefined) {
      queryParameters['filter'] = requestParameters.filter
    }

    if (requestParameters.passThrough !== undefined) {
      queryParameters['pass_through'] = requestParameters.passThrough
    }

    if (requestParameters.fields !== undefined) {
      queryParameters['fields'] = requestParameters.fields
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (requestParameters.consumerId !== undefined && requestParameters.consumerId !== null) {
      headerParameters['x-apideck-consumer-id'] = String(requestParameters.consumerId)
    }

    if (requestParameters.appId !== undefined && requestParameters.appId !== null) {
      headerParameters['x-apideck-app-id'] = String(requestParameters.appId)
    }

    if (requestParameters.serviceId !== undefined && requestParameters.serviceId !== null) {
      headerParameters['x-apideck-service-id'] = String(requestParameters.serviceId)
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = this.configuration.apiKey('Authorization') // apiKey authentication
    }

    const response = await this.request(
      {
        path: `/issue-tracking/collections/{collection_id}/tickets`.replace(
          `{${'collection_id'}}`,
          encodeURIComponent(String(requestParameters.collectionId))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue => GetTicketsResponseFromJSON(jsonValue))
  }

  /**
   * List Tickets
   * List Tickets
   */
  async ticketsAll(
    requestParameters: IssueTrackingApiCollectionTicketsAllRequest,
    initOverrides?: RequestInit
  ): Promise<GetTicketsResponse> {
    const response = await this.ticketsAllRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Delete Ticket
   * Delete Ticket
   */
  async ticketsDeleteRaw(
    requestParameters: IssueTrackingApiCollectionTicketsDeleteRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<DeleteTicketResponse>> {
    if (requestParameters.ticketId === null || requestParameters.ticketId === undefined) {
      throw new runtime.RequiredError(
        'ticketId',
        'Required parameter requestParameters.ticketId was null or undefined when calling ticketsDelete.'
      )
    }

    if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
      throw new runtime.RequiredError(
        'collectionId',
        'Required parameter requestParameters.collectionId was null or undefined when calling ticketsDelete.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.raw !== undefined) {
      queryParameters['raw'] = requestParameters.raw
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (requestParameters.consumerId !== undefined && requestParameters.consumerId !== null) {
      headerParameters['x-apideck-consumer-id'] = String(requestParameters.consumerId)
    }

    if (requestParameters.appId !== undefined && requestParameters.appId !== null) {
      headerParameters['x-apideck-app-id'] = String(requestParameters.appId)
    }

    if (requestParameters.serviceId !== undefined && requestParameters.serviceId !== null) {
      headerParameters['x-apideck-service-id'] = String(requestParameters.serviceId)
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = this.configuration.apiKey('Authorization') // apiKey authentication
    }

    const response = await this.request(
      {
        path: `/issue-tracking/collections/{collection_id}/tickets/{ticket_id}`
          .replace(`{${'ticket_id'}}`, encodeURIComponent(String(requestParameters.ticketId)))
          .replace(
            `{${'collection_id'}}`,
            encodeURIComponent(String(requestParameters.collectionId))
          ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue =>
      DeleteTicketResponseFromJSON(jsonValue)
    )
  }

  /**
   * Delete Ticket
   * Delete Ticket
   */
  async ticketsDelete(
    requestParameters: IssueTrackingApiCollectionTicketsDeleteRequest,
    initOverrides?: RequestInit
  ): Promise<DeleteTicketResponse> {
    const response = await this.ticketsDeleteRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Get Ticket
   * Get Ticket
   */
  async ticketsOneRaw(
    requestParameters: IssueTrackingApiCollectionTicketsOneRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<GetTicketResponse>> {
    if (requestParameters.ticketId === null || requestParameters.ticketId === undefined) {
      throw new runtime.RequiredError(
        'ticketId',
        'Required parameter requestParameters.ticketId was null or undefined when calling ticketsOne.'
      )
    }

    if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
      throw new runtime.RequiredError(
        'collectionId',
        'Required parameter requestParameters.collectionId was null or undefined when calling ticketsOne.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.raw !== undefined) {
      queryParameters['raw'] = requestParameters.raw
    }

    if (requestParameters.fields !== undefined) {
      queryParameters['fields'] = requestParameters.fields
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (requestParameters.consumerId !== undefined && requestParameters.consumerId !== null) {
      headerParameters['x-apideck-consumer-id'] = String(requestParameters.consumerId)
    }

    if (requestParameters.appId !== undefined && requestParameters.appId !== null) {
      headerParameters['x-apideck-app-id'] = String(requestParameters.appId)
    }

    if (requestParameters.serviceId !== undefined && requestParameters.serviceId !== null) {
      headerParameters['x-apideck-service-id'] = String(requestParameters.serviceId)
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = this.configuration.apiKey('Authorization') // apiKey authentication
    }

    const response = await this.request(
      {
        path: `/issue-tracking/collections/{collection_id}/tickets/{ticket_id}`
          .replace(`{${'ticket_id'}}`, encodeURIComponent(String(requestParameters.ticketId)))
          .replace(
            `{${'collection_id'}}`,
            encodeURIComponent(String(requestParameters.collectionId))
          ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue => GetTicketResponseFromJSON(jsonValue))
  }

  /**
   * Get Ticket
   * Get Ticket
   */
  async ticketsOne(
    requestParameters: IssueTrackingApiCollectionTicketsOneRequest,
    initOverrides?: RequestInit
  ): Promise<GetTicketResponse> {
    const response = await this.ticketsOneRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Update Ticket
   * Update Ticket
   */
  async ticketsUpdateRaw(
    requestParameters: IssueTrackingApiCollectionTicketsUpdateRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<UpdateTicketResponse>> {
    if (requestParameters.ticketId === null || requestParameters.ticketId === undefined) {
      throw new runtime.RequiredError(
        'ticketId',
        'Required parameter requestParameters.ticketId was null or undefined when calling ticketsUpdate.'
      )
    }

    if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
      throw new runtime.RequiredError(
        'collectionId',
        'Required parameter requestParameters.collectionId was null or undefined when calling ticketsUpdate.'
      )
    }

    if (requestParameters.ticket === null || requestParameters.ticket === undefined) {
      throw new runtime.RequiredError(
        'ticket',
        'Required parameter requestParameters.ticket was null or undefined when calling ticketsUpdate.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.raw !== undefined) {
      queryParameters['raw'] = requestParameters.raw
    }

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (requestParameters.consumerId !== undefined && requestParameters.consumerId !== null) {
      headerParameters['x-apideck-consumer-id'] = String(requestParameters.consumerId)
    }

    if (requestParameters.appId !== undefined && requestParameters.appId !== null) {
      headerParameters['x-apideck-app-id'] = String(requestParameters.appId)
    }

    if (requestParameters.serviceId !== undefined && requestParameters.serviceId !== null) {
      headerParameters['x-apideck-service-id'] = String(requestParameters.serviceId)
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = this.configuration.apiKey('Authorization') // apiKey authentication
    }

    const response = await this.request(
      {
        path: `/issue-tracking/collections/{collection_id}/tickets/{ticket_id}`
          .replace(`{${'ticket_id'}}`, encodeURIComponent(String(requestParameters.ticketId)))
          .replace(
            `{${'collection_id'}}`,
            encodeURIComponent(String(requestParameters.collectionId))
          ),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: TicketToJSON(requestParameters.ticket)
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue =>
      UpdateTicketResponseFromJSON(jsonValue)
    )
  }

  /**
   * Update Ticket
   * Update Ticket
   */
  async ticketsUpdate(
    requestParameters: IssueTrackingApiCollectionTicketsUpdateRequest,
    initOverrides?: RequestInit
  ): Promise<UpdateTicketResponse> {
    const response = await this.ticketsUpdateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * List Users
   * List Users
   */
  async collectionUsersAllRaw(
    requestParameters: IssueTrackingApiCollectionUsersAllRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<GetCollectionUsersResponse>> {
    if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
      throw new runtime.RequiredError(
        'collectionId',
        'Required parameter requestParameters.collectionId was null or undefined when calling collectionUsersAll.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.raw !== undefined) {
      queryParameters['raw'] = requestParameters.raw
    }

    if (requestParameters.cursor !== undefined) {
      queryParameters['cursor'] = requestParameters.cursor
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.passThrough !== undefined) {
      queryParameters['pass_through'] = requestParameters.passThrough
    }

    if (requestParameters.fields !== undefined) {
      queryParameters['fields'] = requestParameters.fields
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (requestParameters.consumerId !== undefined && requestParameters.consumerId !== null) {
      headerParameters['x-apideck-consumer-id'] = String(requestParameters.consumerId)
    }

    if (requestParameters.appId !== undefined && requestParameters.appId !== null) {
      headerParameters['x-apideck-app-id'] = String(requestParameters.appId)
    }

    if (requestParameters.serviceId !== undefined && requestParameters.serviceId !== null) {
      headerParameters['x-apideck-service-id'] = String(requestParameters.serviceId)
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = this.configuration.apiKey('Authorization') // apiKey authentication
    }

    const response = await this.request(
      {
        path: `/issue-tracking/collections/{collection_id}/users`.replace(
          `{${'collection_id'}}`,
          encodeURIComponent(String(requestParameters.collectionId))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue =>
      GetCollectionUsersResponseFromJSON(jsonValue)
    )
  }

  /**
   * List Users
   * List Users
   */
  async collectionUsersAll(
    requestParameters: IssueTrackingApiCollectionUsersAllRequest,
    initOverrides?: RequestInit
  ): Promise<GetCollectionUsersResponse> {
    const response = await this.collectionUsersAllRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Get user
   * Get user
   */
  async collectionUsersOneRaw(
    requestParameters: IssueTrackingApiCollectionUsersOneRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<GetCollectionUserResponse>> {
    if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
      throw new runtime.RequiredError(
        'collectionId',
        'Required parameter requestParameters.collectionId was null or undefined when calling collectionUsersOne.'
      )
    }

    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling collectionUsersOne.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.raw !== undefined) {
      queryParameters['raw'] = requestParameters.raw
    }

    if (requestParameters.fields !== undefined) {
      queryParameters['fields'] = requestParameters.fields
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (requestParameters.consumerId !== undefined && requestParameters.consumerId !== null) {
      headerParameters['x-apideck-consumer-id'] = String(requestParameters.consumerId)
    }

    if (requestParameters.appId !== undefined && requestParameters.appId !== null) {
      headerParameters['x-apideck-app-id'] = String(requestParameters.appId)
    }

    if (requestParameters.serviceId !== undefined && requestParameters.serviceId !== null) {
      headerParameters['x-apideck-service-id'] = String(requestParameters.serviceId)
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = this.configuration.apiKey('Authorization') // apiKey authentication
    }

    const response = await this.request(
      {
        path: `/issue-tracking/collections/{collection_id}/users/{id}`
          .replace(
            `{${'collection_id'}}`,
            encodeURIComponent(String(requestParameters.collectionId))
          )
          .replace(`{${'id'}}`, encodeURIComponent(String(requestParameters.id))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue =>
      GetCollectionUserResponseFromJSON(jsonValue)
    )
  }

  /**
   * Get user
   * Get user
   */
  async collectionUsersOne(
    requestParameters: IssueTrackingApiCollectionUsersOneRequest,
    initOverrides?: RequestInit
  ): Promise<GetCollectionUserResponse> {
    const response = await this.collectionUsersOneRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * List Collections
   * List Collections
   */
  async collectionsAllRaw(
    requestParameters: IssueTrackingApiCollectionsAllRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<GetCollectionsResponse>> {
    const queryParameters: any = {}

    if (requestParameters.raw !== undefined) {
      queryParameters['raw'] = requestParameters.raw
    }

    if (requestParameters.cursor !== undefined) {
      queryParameters['cursor'] = requestParameters.cursor
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort
    }

    if (requestParameters.passThrough !== undefined) {
      queryParameters['pass_through'] = requestParameters.passThrough
    }

    if (requestParameters.fields !== undefined) {
      queryParameters['fields'] = requestParameters.fields
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (requestParameters.consumerId !== undefined && requestParameters.consumerId !== null) {
      headerParameters['x-apideck-consumer-id'] = String(requestParameters.consumerId)
    }

    if (requestParameters.appId !== undefined && requestParameters.appId !== null) {
      headerParameters['x-apideck-app-id'] = String(requestParameters.appId)
    }

    if (requestParameters.serviceId !== undefined && requestParameters.serviceId !== null) {
      headerParameters['x-apideck-service-id'] = String(requestParameters.serviceId)
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = this.configuration.apiKey('Authorization') // apiKey authentication
    }

    const response = await this.request(
      {
        path: `/issue-tracking/collections`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue =>
      GetCollectionsResponseFromJSON(jsonValue)
    )
  }

  /**
   * List Collections
   * List Collections
   */
  async collectionsAll(
    requestParameters: IssueTrackingApiCollectionsAllRequest = {},
    initOverrides?: RequestInit
  ): Promise<GetCollectionsResponse> {
    const response = await this.collectionsAllRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Get Collection
   * Get Collection
   */
  async collectionsOneRaw(
    requestParameters: IssueTrackingApiCollectionsOneRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<GetCollectionResponse>> {
    if (requestParameters.collectionId === null || requestParameters.collectionId === undefined) {
      throw new runtime.RequiredError(
        'collectionId',
        'Required parameter requestParameters.collectionId was null or undefined when calling collectionsOne.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.raw !== undefined) {
      queryParameters['raw'] = requestParameters.raw
    }

    if (requestParameters.fields !== undefined) {
      queryParameters['fields'] = requestParameters.fields
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (requestParameters.consumerId !== undefined && requestParameters.consumerId !== null) {
      headerParameters['x-apideck-consumer-id'] = String(requestParameters.consumerId)
    }

    if (requestParameters.appId !== undefined && requestParameters.appId !== null) {
      headerParameters['x-apideck-app-id'] = String(requestParameters.appId)
    }

    if (requestParameters.serviceId !== undefined && requestParameters.serviceId !== null) {
      headerParameters['x-apideck-service-id'] = String(requestParameters.serviceId)
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['Authorization'] = this.configuration.apiKey('Authorization') // apiKey authentication
    }

    const response = await this.request(
      {
        path: `/issue-tracking/collections/{collection_id}`.replace(
          `{${'collection_id'}}`,
          encodeURIComponent(String(requestParameters.collectionId))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue =>
      GetCollectionResponseFromJSON(jsonValue)
    )
  }

  /**
   * Get Collection
   * Get Collection
   */
  async collectionsOne(
    requestParameters: IssueTrackingApiCollectionsOneRequest,
    initOverrides?: RequestInit
  ): Promise<GetCollectionResponse> {
    const response = await this.collectionsOneRaw(requestParameters, initOverrides)
    return await response.value()
  }
}
